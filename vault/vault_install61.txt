Mount Vault Secrets through Container Storage Interface (CSI) Volume
https://developer.hashicorp.com/vault/tutorials/kubernetes/kubernetes-secret-store-driver


helm install vault hashicorp/vault \
    --set "server.dev.enabled=true" \
    --set "injector.enabled=false" \
    --set "csi.enabled=true"

[anjack@110master vault]$ helm install vault hashicorp/vault \
>     --set "server.dev.enabled=true" \
>     --set "injector.enabled=false" \
>     --set "csi.enabled=true"
NAME: vault
LAST DEPLOYED: Thu Nov 24 13:32:05 2022
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
Thank you for installing HashiCorp Vault!

Now that you have deployed Vault, you should look over the docs on using
Vault with Kubernetes available here:

https://www.vaultproject.io/docs/


Your release is named vault. To learn more about the release, try:

  $ helm status vault
  $ helm get manifest vault

 default の名前空間にあるすべてのポッドを取得します。
minikube kubectl -- get pods -o wide

[anjack@110master vault]$ minikube kubectl -- get pods -o wide
NAME                       READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES
vault-0                    1/1     Running   0          56s   172.17.0.3   minikube   <none>           <none>
vault-csi-provider-bnjmn   1/1     Running   0          56s   172.17.0.4   minikube   <none>           <none>


Set a secret in Vault
The volume mounted to the pod in the Create a pod with secret mounted section expects a secret stored at the path secret/data/db-pass. When Vault is run in development a KV secret engine is enabled at the path /secret.

First, start an interactive shell session on the vault-0 pod.
minikube kubectl -- exec -it vault-0 -- /bin/sh

[anjack@110master vault]$ minikube kubectl -- exec -it vault-0 -- /bin/sh
/ $

Create a secret at the path secret/db-pass with a password.
vault kv put secret/db-pass password="db-secret-password"

/ $ vault kv put secret/db-pass password="db-secret-password"
=== Secret Path ===
secret/data/db-pass

======= Metadata =======
Key                Value
---                -----
created_time       2022-11-24T04:34:51.902608971Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1

vault kv get secret/db-pass

/ $ vault kv get secret/db-pass
=== Secret Path ===
secret/data/db-pass

======= Metadata =======
Key                Value
---                -----
created_time       2022-11-24T04:34:51.902608971Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1

====== Data ======
Key         Value
---         -----
password    db-secret-password


Configure Kubernetes authentication
Vault provides a Kubernetes authentication method that enables clients to authenticate with a Kubernetes Service Account Token. The Kubernetes resources that access the secret and create the volume authenticate through this method through a role.

Enable the Kubernetes authentication method.
vault auth enable kubernetes

/ $ vault auth enable kubernetes
Success! Enabled kubernetes auth method at: kubernetes/

Configure the Kubernetes authentication method with the Kubernetes API address. It will automatically use the Vault pod's own service account token.
vault write auth/kubernetes/config \
    kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"

/ $ vault write auth/kubernetes/config \
>     kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"
Success! Data written to: auth/kubernetes/config


Create a policy named internal-app. This will be used to give the webapp-sa service account permission to read the kv secret created earlier.
vault policy write internal-app - <<EOF
path "secret/data/db-pass" {
  capabilities = ["read"]
}
EOF

/ $ vault policy write internal-app - <<EOF
> path "secret/data/db-pass" {
>   capabilities = ["read"]
> }
> EOF
Success! Uploaded policy: internal-app


Finally, create a Kubernetes authentication role named database that binds this policy with a Kubernetes service account named webapp-sa.
vault write auth/kubernetes/role/database \
    bound_service_account_names=webapp-sa \
    bound_service_account_namespaces=default \
    policies=internal-app \
    ttl=20m

/ $ vault write auth/kubernetes/role/database \
>     bound_service_account_names=webapp-sa \
>     bound_service_account_namespaces=default \
>     policies=internal-app \
>     ttl=20m
Success! Data written to: auth/kubernetes/role/database


Lastly, exit the vault-0 pod.
 exit


Install the secrets store CSI driver
The Secrets Store CSI driver secrets-store.csi.k8s.io allows Kubernetes to mount multiple secrets, keys, and certs stored in enterprise-grade external secrets stores into their pods as a volume. Once the Volume is attached, the data in it is mounted into the container's file system.

Add the Secrets Store CSI driver Helm repository.
helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts

[anjack@110master vault]$ helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
"secrets-store-csi-driver" has been added to your repositories


Install the latest version of the Kubernetes Secrets Store CSI Driver.
helm install csi secrets-store-csi-driver/secrets-store-csi-driver \
    --set syncSecret.enabled=true

[anjack@110master vault]$ helm install csi secrets-store-csi-driver/secrets-store-csi-driver \
>     --set syncSecret.enabled=true
NAME: csi
LAST DEPLOYED: Thu Nov 24 13:41:14 2022
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
The Secrets Store CSI Driver is getting deployed to your cluster.

To verify that Secrets Store CSI Driver has started, run:

  kubectl --namespace=default get pods -l "app=secrets-store-csi-driver"

Now you can follow these steps https://secrets-store-csi-driver.sigs.k8s.io/getting-started/usage.html
to create a SecretProviderClass resource, and a deployment using the SecretProviderClass.


 default の名前空間にあるすべてのポッドを取得します。
minikube kubectl -- get pods -o wide

[anjack@110master vault]$ minikube kubectl -- get pods -o wide
NAME                                 READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES
csi-secrets-store-csi-driver-rmr7p   3/3     Running   0          61s   172.17.0.5   minikube   <none>           <none>
vault-0                              1/1     Running   0          10m   172.17.0.3   minikube   <none>           <none>
vault-csi-provider-bnjmn             1/1     Running   0          10m   172.17.0.4   minikube   <none>           <none>


Define a SecretProviderClass resource

The Kubernetes Secrets Store CSI Driver Helm chart creates a definition for a SecretProviderClass resource. This resource describes the parameters that are given to the Vault CSI provider. To configure it requires the address of the Vault server, the name of the Vault Kubernetes authentication role, and the secrets.
Kubernetes Secrets Store CSI Driver Helm チャートは、SecretProviderClass リソースの定義を作成します。 
このリソースでは、Vault CSI プロバイダーに提供されるパラメーターについて説明します。 
これを構成するには、Vault サーバーのアドレス、Vault Kubernetes 認証ロールの名前、およびシークレットが必要です。

Define a SecretProviderClass named vault-database.
cat > spc-vault-database.yaml <<EOF
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: vault-database
spec:
  provider: vault
  parameters:
    vaultAddress: "http://vault.default:8200"
    roleName: "database"
    objects: |
      - objectName: "db-password"
        secretPath: "secret/data/db-pass"
        secretKey: "password"
EOF

The vault-database SecretProviderClass describes one secret object:

objectName is a symbolic name for that secret, and the file name to write to.
secretPath is the path to the secret defined in Vault.
secretKey is a key name within that secret.


Create the vault-database SecretProviderClass.
minikube kubectl -- apply --filename spc-vault-database.yaml

[anjack@110master vault]$ minikube kubectl -- apply --filename spc-vault-database.yaml
secretproviderclass.secrets-store.csi.x-k8s.io/vault-database created


Verify that the SecretProviderClass, named vault-database has been defined in the default namespace.
minikube kubectl -- describe SecretProviderClass vault-database

[anjack@110master vault]$ minikube kubectl -- describe SecretProviderClass vault-database
Name:         vault-database
Namespace:    default
Labels:       <none>
Annotations:  <none>
API Version:  secrets-store.csi.x-k8s.io/v1
Kind:         SecretProviderClass
Metadata:
  Creation Timestamp:  2022-11-24T04:54:25Z
  Generation:          1
  Managed Fields:
    API Version:  secrets-store.csi.x-k8s.io/v1
    Fields Type:  FieldsV1
    fieldsV1:
      f:metadata:
        f:annotations:
          .:
          f:kubectl.kubernetes.io/last-applied-configuration:
      f:spec:
        .:
        f:parameters:
          .:
          f:objects:
          f:roleName:
          f:vaultAddress:
        f:provider:
    Manager:         kubectl-client-side-apply
    Operation:       Update
    Time:            2022-11-24T04:54:25Z
  Resource Version:  131980
  UID:               f6464fdb-b1ba-4953-8d61-e2b38acb97ac
Spec:
  Parameters:
    Objects:  - objectName: "db-password"
  secretPath: "secret/data/db-pass"
  secretKey: "password"

    Role Name:      database
    Vault Address:  http://vault.default:8200
  Provider:         vault
Events:             <none>


Create a pod with secret mounted
With the secret stored in Vault, the authentication configured and role created, the provider-vault extension installed and the SecretProviderClass defined it is finally time to create a pod that mounts the desired secret.

Create a service account named webapp-sa.
minikube kubectl -- create serviceaccount webapp-sa

[anjack@110master vault]$ minikube kubectl -- create serviceaccount webapp-sa
serviceaccount/webapp-sa created
[anjack@110master vault]$ minikube kubectl -- get serviceaccount
NAME                       SECRETS   AGE
default                    0         2d3h
internal-app               0         4h9m
secrets-store-csi-driver   0         15m
vault                      0         25m
vault-csi-provider         0         25m
webapp-sa                  0         12s


Define the webapp pod that mounts the secrets volume.
cat > webapp-pod.yaml <<EOF
kind: Pod
apiVersion: v1
metadata:
  name: webapp
spec:
  serviceAccountName: webapp-sa
  containers:
  - image: jweissig/app:0.0.1
    name: webapp
    volumeMounts:
    - name: secrets-store-inline
      mountPath: "/mnt/secrets-store"
      readOnly: true
  volumes:
    - name: secrets-store-inline
      csi:
        driver: secrets-store.csi.k8s.io
        readOnly: true
        volumeAttributes:
          secretProviderClass: "vault-database"
EOF

Create the webapp pod.
minikube kubectl -- apply --filename webapp-pod.yaml

[anjack@110master vault]$ minikube kubectl -- apply --filename webapp-pod.yaml
pod/webapp created


 default の名前空間にあるすべてのポッドを取得します。
minikube kubectl -- get pods -o wide

[anjack@110master vault]$ minikube kubectl -- get pods -o wide
NAME                                 READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES
csi-secrets-store-csi-driver-rmr7p   3/3     Running   0          18m   172.17.0.5   minikube   <none>           <none>
vault-0                              1/1     Running   0          27m   172.17.0.3   minikube   <none>           <none>
vault-csi-provider-bnjmn             1/1     Running   0          27m   172.17.0.4   minikube   <none>           <none>
webapp                               1/1     Running   0          43s   172.17.0.6   minikube   <none>           <none>


Display the password secret written to the file system at /mnt/secrets-store/db-password on the webapp pod.
minikube kubectl -- exec webapp -- cat /mnt/secrets-store/db-password

[anjack@110master vault]$ minikube kubectl -- exec webapp -- cat /mnt/secrets-store/db-password
db-secret-password[anjack@110master vault]$


Sync to a Kubernetes Secret
The Secrets Store CSI Driver also supports syncing to Kubernetes secret objects. Kubernetes secrets are populated with the contents of files from your CSI volume, and their lifetime is closely tied to the lifetime of the pod they are created for.

To add secret syncing for your webapp pod, update the SecretProviderClass to add a secretObjects entry:
cat > spc-vault-database.yaml <<EOF
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: vault-database
spec:
  provider: vault
  secretObjects:
  - data:
    - key: password
      objectName: db-password
    secretName: dbpass
    type: Opaque
  parameters:
    vaultAddress: "http://vault.default:8200"
    roleName: "database"
    objects: |
      - objectName: "db-password"
        secretPath: "secret/data/db-pass"
        secretKey: "password"
EOF

Apply the change:
minikube kubectl -- apply --filename spc-vault-database.yaml

[anjack@110master vault]$ minikube kubectl -- apply --filename spc-vault-database.yaml
secretproviderclass.secrets-store.csi.x-k8s.io/vault-database configured


Next, update the pod to reference the new secret:
cat > webapp-pod.yaml <<EOF
kind: Pod
apiVersion: v1
metadata:
  name: webapp
spec:
  serviceAccountName: webapp-sa
  containers:
  - image: jweissig/app:0.0.1
    name: webapp
    env:
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: dbpass
          key: password
    volumeMounts:
    - name: secrets-store-inline
      mountPath: "/mnt/secrets-store"
      readOnly: true
  volumes:
    - name: secrets-store-inline
      csi:
        driver: secrets-store.csi.k8s.io
        readOnly: true
        volumeAttributes:
          secretProviderClass: "vault-database"
EOF

Notice there is now an env entry, referencing a secret. Delete and redeploy the pod:
minikube kubectl -- delete pod webapp && minikube kubectl -- apply --filename webapp-pod.yaml

[anjack@110master vault]$ minikube kubectl -- delete pod webapp && minikube kubectl -- apply --filename webapp-pod.yaml
pod "webapp" deleted
pod/webapp created


 default の名前空間にあるすべてのポッドを取得します。
minikube kubectl -- get pods -o wide

[anjack@110master vault]$ minikube kubectl -- get pods -o wide
NAME                                 READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES
csi-secrets-store-csi-driver-rmr7p   3/3     Running   0          25m   172.17.0.5   minikube   <none>           <none>
vault-0                              1/1     Running   0          34m   172.17.0.3   minikube   <none>           <none>
vault-csi-provider-bnjmn             1/1     Running   0          34m   172.17.0.4   minikube   <none>           <none>
webapp                               1/1     Running   0          46s   172.17.0.6   minikube   <none>           <none>


You can now verify the Kubernetes secret has been created:
minikube kubectl -- get secret dbpass

[anjack@110master vault]$ minikube kubectl -- get secret dbpass
NAME     TYPE     DATA   AGE
dbpass   Opaque   1      117s


And you can also verify the secret is available in the pod's environment:
minikube kubectl -- exec webapp -- env | grep DB_PASSWORD

[anjack@110master vault]$ minikube kubectl -- exec webapp -- env | grep DB_PASSWORD
DB_PASSWORD=db-secret-password




