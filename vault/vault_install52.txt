Kubernetes クラスタを外部ボールトと統合する

ボールトを開始
Kubernetes クラスターの外部で実行されている Vault は、Vault サーバーがネットワークでアドレス指定可能である限り、そのポッドのいずれかによってアドレス指定できます。 
Vault サーバーがクラスターと同じネットワークにバインドされている場合、Minikube と一緒に Vault をローカルで実行することができます。

1. 新しいターミナルを開き、0.0.0.0:8200 でリクエストをリッスンするルート トークンとしてルートを使用して Vault 開発サーバーを起動します。
vault server -dev -dev-root-token-id root -dev-listen-address 0.0.0.0:8200

-dev-listen-address を 0.0.0.0:8200 に設定すると、
Vault 開発サーバーのデフォルト アドレス (127.0.0.1:8200) がオーバーライドされ、
Vault は共有ネットワークにバインドされるため、Kubernetes クラスターとそのポッドによってアドレス指定可能になります。 .

安全でない操作: 本番環境で Vault 開発サーバーを実行しないでください。 
このアプローチは、このデモンストレーションの開封プロセスを簡素化するためにここでのみ使用されます。

2. Vault CLI の環境変数をエクスポートして、Vault サーバーに対処します。
export VAULT_ADDR=http://0.0.0.0:8200

export VAULT_ADDR=http://192.168.122.75:8200


展開する Web アプリケーションは、Vault がパス secret/devwebapp/config に保存されているユーザー名とパスワードを保存することを期待しています。 
このシークレットを作成するには、キーと値のシークレット エンジンが有効になっており、指定されたパスにユーザー名とパスワードが配置されている必要があります。 
デフォルトでは、Vault 開発サーバーは、secret で始まるパスでキー値シークレット エンジンを有効にして起動します。

3. Login with the root token.
vault login root

[anjack@75maven ~]$ vault login root
Error authenticating: error looking up token: Get "https://127.0.0.1:8200/v1/auth/token/lookup-self": http: server gave HTTP response to HTTPS client
[anjack@75maven ~]$ export VAULT_ADDR=http://0.0.0.0:8200
[anjack@75maven ~]$ vault login root
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                root
token_accessor       DbeHuaSWKF7Gd1e8N9nixEMe
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]
[anjack@75maven ~]$


4. ユーザー名とパスワードを使用して、パス secret/devwebapp/config にシークレットを作成します。
vault kv put secret/devwebapp/config username='giraffe' password='salsa'

[anjack@75maven ~]$ vault kv put secret/devwebapp/config username='giraffe' password='salsa'
======== Secret Path ========
secret/data/devwebapp/config

======= Metadata =======
Key                Value
---                -----
created_time       2022-11-24T01:58:50.847658499Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1

5. シークレットがパス secret/devwebapp/config に保存されていることを確認します。
vault kv get -format=json secret/devwebapp/config | jq ".data.data"
vault kv get -format=yaml secret/devwebapp/config

[anjack@75maven ~]$ vault kv get -format=yaml secret/devwebapp/config
data:
  data:
    password: salsa
    username: giraffe
  metadata:
    created_time: "2022-11-24T01:58:50.847658499Z"
    custom_metadata: null
    deletion_time: ""
    destroyed: false
    version: 1
lease_duration: 0
lease_id: ""
renewable: false
request_id: 331a9388-a5cf-3628-a8ea-f8202b3762a5
warnings: null


ボールト アドレスを特定する

1. minikube SSH セッションを開始します。
minikube ssh

Create a variable named EXTERNAL_VAULT_ADDR to capture the Minikube gateway address.

 EXTERNAL_VAULT_ADDR=$(minikube ssh "dig +short host.docker.internal" | tr -d '\r')
Copy
Verify that the variable contains the ip address you saw when executed in the minikube shell.

 echo $EXTERNAL_VAULT_ADDR
192.168.65.2

ハードコーディングされた Vault アドレスを使用してアプリケーションをデプロイする

クラスター内のポッドが Vault に対処する最も直接的な方法は、
アプリケーション コードで定義されているか、
環境変数として提供されているハードコーディングされたネットワーク アドレスを使用することです。 
Vault アドレスのオーバーライドを可能にする Web アプリケーションを作成して公開しました。

1. Create a Kubernetes service account named internal-app.
minikube kubectl -- create sa internal-app

minikube kubectl -- get sa

[anjack@110master vault]$ minikube kubectl -- get sa
NAME           SECRETS   AGE
default        0         22m
internal-app   0         17m


2. VAULT_ADDR を EXTERNAL_VAULT_ADDR に設定する Web アプリケーションで devwebapp という名前のポッドを定義します。
vi で対応

cat > devwebapp.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: devwebapp
  labels:
    app: devwebapp
spec:
  serviceAccountName: internal-app
  containers:
    - name: app
      image: burtlo/devwebapp-ruby:k8s
      env:
      - name: VAULT_ADDR
        value: "http://192.168.122.75:8200"
      - name: VAULT_TOKEN
        value: root
EOF

apiVersion: v1
kind: Pod
metadata:
  name: devwebapp
  labels:
    app: devwebapp
spec:
  serviceAccountName: internal-app
  containers:
    - name: app
      image: burtlo/devwebapp-ruby:k8s
      env:
      - name: VAULT_ADDR
        value: "http://192.168.122.75:8200"
      - name: VAULT_TOKEN
        value: root

3. Create the devwebapp pod.
minikube kubectl -- apply --filename devwebapp.yaml

[anjack@110master vault]$ minikube kubectl -- apply --filename devwebapp.yaml
pod/devwebapp created

オフサイトの名前空間にあるすべてのポッドを取得します。
minikube kubectl -- get pods -o wide

[anjack@110master vault]$ minikube kubectl -- get pods -o wide
NAME                      READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES
devwebapp                 1/1     Running   0          47s   172.17.0.7   minikube   <none>           <none>
issues-7f5d8698f6-9wf92   2/2     Running   0          15m   172.17.0.9   minikube   <none>           <none>


minikube kubectl -- exec devwebapp -- curl -s 192.168.122.75:8080 ; echo

export VAULT_ADDR=http://192.168.122.75:8200

minikube kubectl -- exec devwebapp -- curl -s localhost:8080 ; echo

[anjack@110master vault]$ minikube kubectl -- exec devwebapp -- curl -s localhost:8080 ; echo
{"password"=>"salsa", "username"=>"giraffe"}


Deploy service and endpoints to address an external Vault
An external Vault may not have a static network address that services in the cluster can rely upon. When Vault's network address changes each service also needs to change to continue its operation. Another approach to manage this network address is to define a Kubernetes service and endpoints.

A service creates an abstraction around pods or an external service. When an application running in a pod requests the service, that request is routed to the endpoints that share the service name.

1. Define a service named external-vault and a corresponding endpoint configured to address the EXTERNAL_VAULT_ADDR.

cat > external-vault.yaml <<EOF
---
apiVersion: v1
kind: Service
metadata:
  name: external-vault
  namespace: default
spec:
  ports:
  - protocol: TCP
    port: 8200
---
apiVersion: v1
kind: Endpoints
metadata:
  name: external-vault
subsets:
  - addresses:
      - ip: $EXTERNAL_VAULT_ADDR
    ports:
      - port: 8200
EOF

[anjack@110master vault]$ cat > external-vault.yaml <<EOF
> ---
> apiVersion: v1
> kind: Service
> metadata:
>   name: external-vault
>   namespace: default
> spec:
>   ports:
>   - protocol: TCP
>     port: 8200
> ---
> apiVersion: v1
> kind: Endpoints
> metadata:
>   name: external-vault
> subsets:
>   - addresses:
>       - ip: $EXTERNAL_VAULT_ADDR
>     ports:
>       - port: 8200
> EOF
[anjack@110master vault]$
[anjack@110master vault]$ cat external-vault.yaml
---
apiVersion: v1
kind: Service
metadata:
  name: external-vault
  namespace: default
spec:
  ports:
  - protocol: TCP
    port: 8200
---
apiVersion: v1
kind: Endpoints
metadata:
  name: external-vault
subsets:
  - addresses:
      - ip: 192.168.122.75
    ports:
      - port: 8200
[anjack@110master vault]$


2. Create the external-vault service.
minikube kubectl -- apply --filename external-vault.yaml

[anjack@110master vault]$ minikube kubectl -- apply --filename external-vault.yaml
service/external-vault created
endpoints/external-vault created

3. Verify that the external-vault service is addressable from within the devwebapp pod.
minikube kubectl -- exec devwebapp -- curl -s http://external-vault:8200/v1/sys/seal-status | jq

minikube kubectl -- exec devwebapp -- curl -s http://external-vault:8200/v1/sys/seal-status

[anjack@110master vault]$ minikube kubectl -- exec devwebapp -- curl -s http://external-vault:8200/v1/sys/seal-status
{"type":"shamir","initialized":true,"sealed":false,"t":1,"n":1,"progress":0,"nonce":"","version":"1.12.0","build_date":"2022-10-10T18:14:33Z","migration":false,"cluster_name":"vault-cluster-dd4b38ca","cluster_id":"b33eeb06-c6f4-6ede-3932-8585421d0c93","recovery_seal":false,"storage_type":"inmem"}

[anjack@110master vault]$ minikube kubectl -- exec devwebapp -- curl -s http://external-vault:8200/v1/sys/seal-status | jq
{
  "type": "shamir",
  "initialized": true,
  "sealed": false,
  "t": 1,
  "n": 1,
  "progress": 0,
  "nonce": "",
  "version": "1.12.0",
  "build_date": "2022-10-10T18:14:33Z",
  "migration": false,
  "cluster_name": "vault-cluster-dd4b38ca",
  "cluster_id": "b33eeb06-c6f4-6ede-3932-8585421d0c93",
  "recovery_seal": false,
  "storage_type": "inmem"
}

以下は、pod-devwebapp-through-service.yamlが不明なため、実施しない。
4. Create a pod that sets the VAULT_ADDR to the external-vault service.
kubectl apply --filename=pod-devwebapp-through-service.yaml


