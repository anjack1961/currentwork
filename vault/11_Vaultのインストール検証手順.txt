
事前作業
1. ストレージクラスの作成 ローカル
cat > local-storage.yaml << EOF
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
EOF

kubectl apply -f local-storage.yaml

kubectl get sc

2. PersistentVolumeの作成
Raftで作成されるPod数3に対してPersistentVolumeを4作成する。
ノードに対する割り当てが自動で行われるためと思われる。

kubectl get nodes

$ cat persistentvolume/pv01.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv01
spec:
  capacity:
    storage: 10Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local:
    path: /mnt/disks/ssd1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - 60node01.aandby.ga

$ cat persistentvolume/pv02.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv02
spec:
  capacity:
    storage: 10Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local:
    path: /mnt/disks/ssd2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - 60node01.aandby.ga

$ cat persistentvolume/pv03.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv03
spec:
  capacity:
    storage: 10Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local:
    path: /mnt/disks/ssd1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - 60node02.aandby.ga

$ cat persistentvolume/pv04.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv04
spec:
  capacity:
    storage: 10Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local:
    path: /mnt/disks/ssd2
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - 60node02.aandby.ga

kubectl apply -f persistentvolume

kubectl get sc,pv

3. helmによるVault Raftのインストール
cat > storageclass-values.yml <<EOF
server:
  affinity: ""
  dataStorage:
    storageClass: local-storage
  ha:
    enabled: true
    raft:
      enabled: true
EOF

kubectl create ns vault

kubectl get ns vault

helm install vault hashicorp/vault -n vault --values storageclass-values.yml

kubectl -n vault get sc,pv,pvc

kubectl -n vault get all

kubectl -n vault get pods -o wide

4. Vault初期化
1 つのキー共有と 1 つのキーしきい値で vault-0 を初期化します。
kubectl -n vault exec vault-0 -- vault operator init \
    -key-shares=1 \
    -key-threshold=1 \
    -format=json > cluster-keys.json

cluster-keys.json にある unseal キーを表示します。
jq -r ".unseal_keys_b64[]" cluster-keys.json

VAULT_UNSEAL_KEY という名前の変数を作成して、Vault 開封キーを取得します。
VAULT_UNSEAL_KEY=$(jq -r ".unseal_keys_b64[]" cluster-keys.json)

Vault-0 ポッドで実行されている Vault をアンシールします。
kubectl -n vault exec vault-0 -- vault operator unseal $VAULT_UNSEAL_KEY

vault-1 ポッドを Raft クラスタに参加させます。
kubectl -n vault exec -ti vault-1 -- vault operator raft join http://vault-0.vault-internal:8200

vault-2 ポッドを Raft クラスタに参加させます。
kubectl -n vault exec -ti vault-2 -- vault operator raft join http://vault-0.vault-internal:8200

kubectl -n vault get pods

上記の開封キーを使用して、vault-1 を開封します。
kubectl -n vault exec -ti vault-1 -- vault operator unseal $VAULT_UNSEAL_KEY

上記の開封キーを使用して、vault-2 を開封します。
kubectl -n vault exec -ti vault-2 -- vault operator unseal $VAULT_UNSEAL_KEY

kubectl -n vault get pods

kubectl -n vault exec vault-0 -- vault status

5. Vault でシークレットを設定する

cluster-keys.json で見つかったルート トークンを表示します。
jq -r ".root_token" cluster-keys.json

vault-0 ポッドでインタラクティブ シェル セッションを開始します。
kubectl -n vault exec --stdin=true --tty=true vault-0 -- /bin/sh

プロンプトが表示されたら、ルート トークンを使用してログインします。
vault login

パス シークレットで kv-v2 シークレット エンジンのインスタンスを有効にします。
vault secrets enable -path=secret kv-v2

ユーザー名とパスワードを使用して、パス secret/webapp/config にシークレットを作成します。
vault kv put secret/webapp/config username="static-user" password="static-password"

シークレットがパス secret/webapp/config で定義されていることを確認します。
vault kv get secret/webapp/config

vault-0 ポッドを終了します。
exit

6. Kubernetes 認証を構成する
vault-0 ポッドでインタラクティブ シェル セッションを開始します。
kubectl -n vault exec --stdin=true --tty=true vault-0 -- /bin/sh

Kubernetes 認証方法を有効にします。
vault auth enable kubernetes

Kubernetes API の場所を使用するように Kubernetes 認証方法を構成します。
vault write auth/kubernetes/config \
    kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"

パス secret/data/webapp/config でシークレットの読み取り機能を有効にする webapp という名前のポリシーを書き出します。
vault policy write webapp - <<EOF
path "secret/data/webapp/config" {
  capabilities = ["read"]
}
EOF

Kubernetes サービス アカウント名webappと webapp ポリシーを接続する、名前空間webapp
webapp という名前の Kubernetes 認証ロールを作成します。

vault write auth/kubernetes/role/webapp \
        bound_service_account_names=webapp \
        bound_service_account_namespaces=webapp \
        policies=webapp \
        ttl=24h

vault write auth/kubernetes/role/webapp \
        bound_service_account_names="*" \
        bound_service_account_namespaces="*" \
        policies=webapp \
        ttl=24h

vault-0 ポッドを終了します。
exit

7. Web アプリケーションを起動する
名前空間をwebapp
kubectl create ns webapp

kubectl get ns webapp

kubectl -n webapp get sa

kubectl -n webapp create sa webapp

kubectl -n webapp get sa

cat > deployment-01-webapp.yml << EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
  labels:
    app: webapp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      serviceAccountName: webapp
      containers:
        - name: app
          image: burtlo/exampleapp-ruby:k8s
          imagePullPolicy: Always
          env:
            - name: VAULT_ADDR
              value: 'http://vault.vault.svc.cluster.local:8200'
            - name: JWT_PATH
              value: '/var/run/secrets/kubernetes.io/serviceaccount/token'
            - name: SERVICE_PORT
              value: '8080'
EOF

ファイル deployment-01-webapp.yml を適用して、webapp を Kubernetes にデプロイします。
kubectl -n webapp apply --filename deployment-01-webapp.yml

デフォルトの名前空間内のすべてのポッドを取得します。
kubectl -n webapp get pods

別のターミナルで、http://localhost:8080 に対して行われたすべてのリクエストを、ポート 8080 の webapp ポッドにポート転送します。
kubectl -n webapp port-forward \
    $(kubectl -n webapp get pod -l app=webapp -o jsonpath="{.items[0].metadata.name}") \
    8080:8080

元のターミナルで、http://localhost:8080 で curl リクエストを実行します。
curl http://localhost:8080



[testuser@60node01 ~]$ sudo rm -rf /mnt/disks
[sudo] testuser のパスワード:
[testuser@60node01 ~]$ sudo mkdir -p /mnt/disks/ssd1; sudo chmod 777 /mnt/disks/ssd1
[testuser@60node01 ~]$ sudo mkdir -p /mnt/disks/ssd2; sudo chmod 777 /mnt/disks/ssd2
[testuser@60node01 ~]$ ls -l /mnt/disks
合計 0
drwxrwxrwx 2 root root 6 12月 13 09:11 ssd1
drwxrwxrwx 2 root root 6 12月 13 09:11 ssd2

[testuser@60node02 ~]$ sudo rm -rf /mnt/disks
[sudo] testuser のパスワード:
[testuser@60node02 ~]$ sudo mkdir -p /mnt/disks/ssd1; sudo chmod 777 /mnt/disks/ssd1
[testuser@60node02 ~]$ sudo mkdir -p /mnt/disks/ssd2; sudo chmod 777 /mnt/disks/ssd2
[testuser@60node02 ~]$ ls -l /mnt/disks
合計 0
drwxrwxrwx 2 root root 6 12月 13 09:12 ssd1
drwxrwxrwx 2 root root 6 12月 13 09:13 ssd2

[testuser@60master ~]$ kubectl -n webapp port-forward \
>     $(kubectl -n webapp get pod -l app=webapp -o jsonpath="{.items[0].metadata.name}") \
>     8080:8080
Forwarding from 127.0.0.1:8080 -> 8080
Forwarding from [::1]:8080 -> 8080


Handling connection for 8080
Handling connection for 8080
Handling connection for 8080
Handling connection for 8080

