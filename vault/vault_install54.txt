Integrate a Kubernetes Cluster with an External Vault
Kubernetes クラスタを外部ボールトと統合する
https://developer.hashicorp.com/vault/tutorials/kubernetes/kubernetes-external-vault

ボールトを開始

1. 新しいターミナルを開き、0.0.0.0:8200 でリクエストをリッスンするルート トークンとしてルートを使用して Vault 開発サーバーを起動します。
$ vault server -dev -dev-root-token-id root -dev-listen-address 0.0.0.0:8200
==> Vault server configuration:

             Api Address: http://0.0.0.0:8200
                     Cgo: disabled
         Cluster Address: https://0.0.0.0:8201
              Go Version: go1.19.2
              Listener 1: tcp (addr: "0.0.0.0:8200", cluster address: "0.0.0.0:8201", max_request_duration: "1m30s", max_request_size: "33554432", tls: "disabled")
               Log Level: info
                   Mlock: supported: true, enabled: false
           Recovery Mode: false
                 Storage: inmem
                 Version: Vault v1.12.1, built 2022-10-27T12:32:05Z
             Version Sha: e34f8a14fb7a88af4640b09f3ddbb5646b946d9c

==> Vault server started! Log data will stream in below:
・・・
WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variables:

    $ export VAULT_ADDR='http://0.0.0.0:8200'

The unseal key and root token are displayed below in case you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: Il4YKblxtWQhlpwcyyTol8A8+qL9/2xqD11bq2TArqE=
Root Token: root

Development mode should NOT be used in production installations!



2. Vault CLI の環境変数をエクスポートして、Vault サーバーに対処します。
$ export VAULT_ADDR=http://0.0.0.0:8200
$ echo $VAULT_ADDR
http://0.0.0.0:8200


3. Login with the root token.
$ vault login root
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                root
token_accessor       gWKldCJlRm1AmfFKUCT4cuTr
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]

4. ユーザー名とパスワードを使用して、パス secret/devwebapp/config にシークレットを作成します。
$ vault kv put secret/devwebapp/config username='giraffe' password='salsa'
======== Secret Path ========
secret/data/devwebapp/config

======= Metadata =======
Key                Value
---                -----
created_time       2022-11-28T00:44:43.750908128Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1

5. シークレットがパス secret/devwebapp/config に保存されていることを確認します。
$ vault kv get -format=json secret/devwebapp/config | jq ".data.data"
{
  "password": "salsa",
  "username": "giraffe"
}


ボールト アドレスを特定する

$ export EXTERNAL_VAULT_ADDR=192.168.122.110
$ echo $EXTERNAL_VAULT_ADDR
192.168.122.110



ハードコーディングされた Vault アドレスを使用してアプリケーションをデプロイする

1. Create a Kubernetes service account named internal-app.
$ minikube kubectl -- create sa internal-app
serviceaccount/internal-app created
$ minikube kubectl -- get sa
NAME           SECRETS   AGE
default        0         5d23h
internal-app   0         70s

2. VAULT_ADDR を EXTERNAL_VAULT_ADDR に設定する Web アプリケーションで devwebapp という名前のポッドを定義します。
$ cat > devwebapp.yaml <<EOF
> apiVersion: v1
> kind: Pod
> metadata:
>   name: devwebapp
>   labels:
>     app: devwebapp
> spec:
>   serviceAccountName: internal-app
>   containers:
>     - name: app
>       image: burtlo/devwebapp-ruby:k8s
>       env:
>       - name: VAULT_ADDR
>         value: "http://$EXTERNAL_VAULT_ADDR:8200"
>       - name: VAULT_TOKEN
>         value: root
> EOF

3. Create the devwebapp pod.
$ minikube kubectl -- apply --filename devwebapp.yaml
pod/devwebapp created

4. default の名前空間にあるすべてのポッドを取得します。
$ minikube kubectl -- get pods
NAME        READY   STATUS    RESTARTS   AGE
devwebapp   1/1     Running   0          104s

5. devwebapp ポッド内から localhost:8080 で提供されるコンテンツをリクエストします。
$ minikube kubectl -- exec devwebapp -- curl -s localhost:8080 ; echo
{"password"=>"salsa", "username"=>"giraffe"}



サービスとエンドポイントを展開して、外部の Vault に対処する

1. external-vault という名前のサービスと、EXTERNAL_VAULT_ADDR に対応するように構成された対応するエンドポイントを定義します。
$ cat > external-vault.yaml <<EOF
> ---
> apiVersion: v1
> kind: Service
> metadata:
>   name: external-vault
>   namespace: default
> spec:
>   ports:
>   - protocol: TCP
>     port: 8200
> ---
> apiVersion: v1
> kind: Endpoints
> metadata:
>   name: external-vault
> subsets:
>   - addresses:
>       - ip: $EXTERNAL_VAULT_ADDR
>     ports:
>       - port: 8200
> EOF

2. Create the external-vault service.
$ minikube kubectl -- apply --filename external-vault.yaml
service/external-vault created
endpoints/external-vault created

3. external-vault サービスが devwebapp ポッド内からアドレス指定可能であることを確認します。
$ minikube kubectl -- exec devwebapp -- curl -s http://external-vault:8200/v1/sys/seal-status | jq
{
  "type": "shamir",
  "initialized": true,
  "sealed": false,
  "t": 1,
  "n": 1,
  "progress": 0,
  "nonce": "",
  "version": "1.12.1",
  "build_date": "2022-10-27T12:32:05Z",
  "migration": false,
  "cluster_name": "vault-cluster-a81725fe",
  "cluster_id": "e5b138b7-332f-c42e-676e-c7dbfd250802",
  "recovery_seal": false,
  "storage_type": "inmem"
}

4. VAULT_ADDR を external-vault サービスに設定する Pod を作成します。
cat > pod-devwebapp-through-service.yaml <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: devwebapp-through-service
  labels:
    app: devwebapp-through-service
spec:
  serviceAccountName: internal-app
  containers:
    - name: app
      image: burtlo/devwebapp-ruby:k8s
      env:
      - name: VAULT_ADDR
        value: "http://external-vault:8200"
      - name: VAULT_TOKEN
        value: root
EOF

$ cat > pod-devwebapp-through-service.yaml <<EOF
> apiVersion: v1
> kind: Pod
> metadata:
>   name: devwebapp-through-service
>   labels:
>     app: devwebapp-through-service
> spec:
>   serviceAccountName: internal-app
>   containers:
>     - name: app
>       image: burtlo/devwebapp-ruby:k8s
>       env:
>       - name: VAULT_ADDR
>         value: "http://external-vault:8200"
>       - name: VAULT_TOKEN
>         value: root
> EOF

$ minikube kubectl -- apply --filename=pod-devwebapp-through-service.yaml
pod/devwebapp-through-service created

5. default の名前空間にあるすべてのポッドを取得します。
$ minikube kubectl -- get pods
NAME                        READY   STATUS    RESTARTS   AGE
devwebapp                   1/1     Running   0          21m
devwebapp-through-service   1/1     Running   0          65s

6. devwebapp-through-service ポッド内から localhost:8080 で提供されるコンテンツをリクエストします。
$ minikube kubectl -- exec devwebapp-through-service -- curl -s localhost:8080 ; echo
{"password"=>"salsa", "username"=>"giraffe"}




Install the Vault Helm chart configured to address an external Vault
外部 Vault に対応するように構成された Vault Helm チャートをインストールする

3. エクスターナル モードで実行されている Vault サーバーの最新バージョンをインストールします。
$ helm install vault hashicorp/vault \
>     --set "injector.externalVaultAddr=http://external-vault:8200"
NAME: vault
LAST DEPLOYED: Mon Nov 28 10:50:46 2022
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
Thank you for installing HashiCorp Vault!

Now that you have deployed Vault, you should look over the docs on using
Vault with Kubernetes available here:

https://www.vaultproject.io/docs/


Your release is named vault. To learn more about the release, try:

  $ helm status vault
  $ helm get manifest vault

4. デフォルトの名前空間にあるすべてのポッドを取得します。
$ minikube kubectl -- get pods
NAME                                    READY   STATUS    RESTARTS   AGE
devwebapp                               1/1     Running   0          5m47s
devwebapp-through-service               1/1     Running   0          2m52s
vault-agent-injector-68f49b54df-wxsfv   1/1     Running   0          109s

5. Describe the vault service account.
$ minikube kubectl -- describe serviceaccount vault
Name:                vault
Namespace:           default
Labels:              app.kubernetes.io/instance=vault
                     app.kubernetes.io/managed-by=Helm
                     app.kubernetes.io/name=vault
                     helm.sh/chart=vault-0.22.1
Annotations:         meta.helm.sh/release-name: vault
                     meta.helm.sh/release-namespace: default
Image pull secrets:  <none>
Mountable secrets:   <none>
Tokens:              <none>
Events:              <none>

6. Kubernetes 1.24+ のみ: マウント可能なシークレットの名前は Kubernetes 1.23 で表示されます。 
Kubernetes 1.24 以降では、トークンは自動的に作成されないため、明示的に作成する必要があります。
$ cat > vault-secret.yaml <<EOF
> apiVersion: v1
> kind: Secret
> metadata:
>   name: vault-token-g955r
>   annotations:
>     kubernetes.io/service-account.name: vault
> type: kubernetes.io/service-account-token
> EOF

$ minikube kubectl -- apply -f vault-secret.yaml
secret/vault-token-g955r created

7. シークレット名を格納する VAULT_HELM_SECRET_NAME という名前の変数を作成します。
$ VAULT_HELM_SECRET_NAME=$(minikube kubectl -- get secrets --output=json | jq -r '.items[].metadata | select(.name|startswith("vault-token-")).name')
$ echo $VAULT_HELM_SECRET_NAME
vault-token-g955r

8. Describe the vault-token secret.
$ minikube kubectl -- describe secret $VAULT_HELM_SECRET_NAME
Name:         vault-token-g955r
Namespace:    default
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: vault
              kubernetes.io/service-account.uid: 27f1bbd7-4170-4fb1-95b4-5df2185950ff

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1111 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IlFSdzhkMHNuOVZTeTlMNDU1U3VMLUU4Y3FsMUdZbTVvWXd4Y21kX2NEOTgifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6InZhdWx0LXRva2VuLWc5NTVyIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6InZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiMjdmMWJiZDctNDE3MC00ZmIxLTk1YjQtNWRmMjE4NTk1MGZmIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50OmRlZmF1bHQ6dmF1bHQifQ.qczPCYsM1rv59VCcY2qkEkX_dwNnTS29Gvw3NHojl5Z2u1B-tFhXypgzWq8dmuRouZoVh_S03IvAKgs0Oeu_DdwGQTvJ8cEHWS2yPH1TnGY7dSzq0khAsoLGOlMSUXyrYbQXKFwT4ACjJNJW0K76ZY4CBWAsLpgITjEVjMVo4UsC7jwxwTXq18zVN9Z9aHCFEHZIQ0zeMhxXq5I-sIFW6MXKyK6gcuxrYyQeoEPa5K-g5OvFJon9vyXBdip-ac3kI0fk5lOMDql6YKKl_gtgPqFnnjPF-ghIKaaxQiQw2kjsgO2st3DICeUr7_Oz778dUFydPQmeY83Guh_NS56neQ



Kubernetes 認証を構成する
Vault は、クライアントが Kubernetes サービス アカウント トークンで認証できるようにする Kubernetes 認証方法を提供します。

1. Kubernetes 認証方法を有効にします。
$ vault auth enable kubernetes
Success! Enabled kubernetes auth method at: kubernetes/

2. シークレットから JSON Web トークン (JWT) を取得します。
$ TOKEN_REVIEW_JWT=$(minikube kubectl -- get secret $VAULT_HELM_SECRET_NAME --output='go-template={{ .data.token }}' | base64 --decode)

3.Kubernetes CA 証明書を取得します。
$ KUBE_CA_CERT=$(minikube kubectl -- config view --raw --minify --flatten --output='jsonpath={.clusters[].cluster.certificate-authority-data}' | base64 --decode)

4. Kubernetes ホスト URL を取得します。
$ KUBE_HOST=$(minikube kubectl -- config view --raw --minify --flatten --output='jsonpath={.clusters[].cluster.server}')

5. サービス アカウント トークン、Kubernetes ホストの場所、その証明書、およびそのサービス アカウント発行者名を使用するように Kubernetes 認証方法を構成します。
$ vault write auth/kubernetes/config \
>      token_reviewer_jwt="$TOKEN_REVIEW_JWT" \
>      kubernetes_host="$KUBE_HOST" \
>      kubernetes_ca_cert="$KUBE_CA_CERT" \
>      issuer="https://kubernetes.default.svc.cluster.local"
Success! Data written to: auth/kubernetes/config

6.パス secret/data/devwebapp/config でシークレットの読み取り機能を有効にする devwebapp という名前のポリシーを書き出します。
$ vault policy write devwebapp - <<EOF
> path "secret/data/devwebapp/config" {
>   capabilities = ["read"]
> }
> EOF
Success! Uploaded policy: devwebapp

7. devweb-app という名前の Kubernetes 認証ロールを作成します。
$ vault write auth/kubernetes/role/devweb-app \
>      bound_service_account_names=internal-app \
>      bound_service_account_namespaces=default \
>      policies=devwebapp \
>      ttl=24h
Success! Data written to: auth/kubernetes/role/devweb-app



シークレットをポッドに注入する

1.お好みのテキスト エディターを使用して、pod-devwebapp-with-annotations.yaml という注釈を付けてポッドを調べます。

$ cat > pod-devwebapp-with-annotations.yaml << EOF
> apiVersion: v1
> kind: Pod
> metadata:
>   name: devwebapp-with-annotations
>   labels:
>     app: devwebapp-with-annotations
>   annotations:
>     vault.hashicorp.com/agent-inject: 'true'
>     vault.hashicorp.com/role: 'devweb-app'
>     vault.hashicorp.com/agent-inject-secret-credentials.txt: 'secret/data/devwebapp/config'
> spec:
>   serviceAccountName: internal-app
>   containers:
>     - name: app
>       image: burtlo/devwebapp-ruby:k8s
> EOF

2. devwebapp-with-annotations ポッドを作成します。
$ minikube kubectl -- apply --filename pod-devwebapp-with-annotations.yaml
pod/devwebapp-with-annotations created

3. default の名前空間にあるすべてのポッドを取得します。
$ minikube kubectl -- get pods
NAME                                    READY   STATUS    RESTARTS   AGE
devwebapp                               1/1     Running   0          22m
devwebapp-through-service               1/1     Running   0          19m
devwebapp-with-annotations              2/2     Running   0          35s
vault-agent-injector-68f49b54df-wxsfv   1/1     Running   0          18m

4. devwebapp-with-annotations ポッドのファイル /vault/secrets/secret-credentials.txt に書き込まれたシークレットを表示します。
$ minikube kubectl -- exec -it devwebapp-with-annotations -c app -- cat /vault/secrets/credentials.txt
data: map[password:salsa username:giraffe]
metadata: map[created_time:2022-11-28T00:44:43.750908128Z custom_metadata:<nil> deletion_time: destroyed:false version:1]















